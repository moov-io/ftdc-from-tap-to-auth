package paycard

import (
	"encoding/hex"
	"fmt"
	"strings"
)

const (
	DefaultTransactionQualifiers = "B600C000"
	DefaultCountryCode           = "0840"
	DefaultCurrencyCode          = "0840"
	DefaultVerificationResults   = "0000000000"
	DefaultTransactionDate       = "210101"
	DefaultUnpredictableNumber   = "A1B2C3D4"
)

type Transaction struct {
	// AuthorizedAmount is the amount authorized for the transaction.
	AuthorizedAmount string

	// SecondaryAmount is the cashback amount.
	SecondaryAmount string

	// TransactionType is the type of transaction, e.g., purchase, cash advance, etc.
	TransactionType string

	AID string
}

type Terminal struct {
	// Opts is the options for the terminal.
	Opts Options
}

// Option is a function on the options for a connection.
type Option func(*Options) error

// Options can be used to configure a Terminal.
type Options struct {
	// CountryCode is the terminal country code.
	CountryCode string
	// VerificationResults is the terminal verification results of the terminals risk management checks.
	VerificationResults string
	// CurrencyCode is the currency code of the transaction.
	CurrencyCode string
	// TransactionDate is the date of the transaction.
	TransactionDate string
	// UnpredictableNumber is a four-byte random number generated by the terminal for transaction uniqueness.
	UnpredictableNumber string
}

// GetDefaultOptions returns the default options for a Terminal.
func GetDefaultOptions() Options {
	return Options{
		CountryCode:         DefaultCountryCode,
		VerificationResults: DefaultVerificationResults,
		CurrencyCode:        DefaultCurrencyCode,
		TransactionDate:     DefaultTransactionDate,
		UnpredictableNumber: DefaultUnpredictableNumber,
	}
}

// NewTerminal returns a new terminal.
func NewTerminal(options ...Option) (*Terminal, error) {
	opts := GetDefaultOptions()
	for _, opt := range options {
		if opt != nil {
			if err := opt(&opts); err != nil {
				return nil, err
			}
		}
	}
	terminal := &Terminal{
		Opts: opts,
	}
	return terminal, nil
}

// WithCountryCode sets the country code for the terminal.
func WithCountryCode(code string) Option {
	// todo: validate that it is a valid country code or use defaul? or return error?
	return func(o *Options) error {
		o.CountryCode = code
		return nil
	}
}

// WithTransactionDate sets the transaction date for the terminal.
func WithTransactionDate(date string) Option {
	// todo: validate that it is a valid date or use defaul? or return error?
	return func(o *Options) error {
		o.TransactionDate = date
		return nil
	}
}

// WithCurrencyCode sets the currency code for the terminal.
func WithCurrencyCode(code string) Option {
	// todo: validate that it is a valid currency code or use defaul? or return error?
	return func(o *Options) error {
		o.CurrencyCode = code
		return nil
	}
}

// NewSession returns a new session.
func NewSession() *Transaction {
	return &Transaction{
		AuthorizedAmount: "0",
	}
}

const (
	VisaContactlessTTQ    = "B600C000" // Visa's standard TTQ
	MastercardContactless = "B600C000" // Mastercard's standard TTQ
	DiscoverContactless   = "3600C000" // Discover's standard TTQ
	AmexContactless       = "B600C000" // Amex's standard TTQ
)

// TransactionQualifiers returns the terminal transaction qualifiers.
func (t *Terminal) TransactionQualifiers(session *Transaction, length int) []byte {
	//9F66 (TTQ): B600C000 is a common setting indicating that the terminal supports EMV mode, magstripe mode, Consumer Device Cardholder Verification Method (CDCVM), and online PIN.
	var ttqValue string

	// Determine TTQ based on AID prefix
	switch {
	case strings.HasPrefix(session.AID, "A000000003"): // Visa
		ttqValue = VisaContactlessTTQ
	case strings.HasPrefix(session.AID, "A000000004"): // Mastercard
		ttqValue = MastercardContactless
	case strings.HasPrefix(session.AID, "A000000152"): // Discover
		ttqValue = DiscoverContactless
	case strings.HasPrefix(session.AID, "A000000025"): // Amex
		ttqValue = AmexContactless
	default:
		ttqValue = DefaultTransactionQualifiers
	}

	tq, _ := hex.DecodeString(ttqValue)
	return PadBinary(tq, length)
}

// AuthorizedAmount returns the authorized amount.
func (t *Terminal) AuthorizedAmount(s *Transaction, length int) []byte {
	// 9F02 (Authorized Amount): The amount is in cents (or other minor currency units). For $12.34, this is represented as 000000001234.
	return PadNumeric(s.AuthorizedAmount, length)
}

// SecondaryAmount returns the secondary amount. This is the cashback amount.
func (t *Terminal) SecondaryAmount(s *Transaction, length int) []byte {
	// 9F03 (Secondary Amount): Also in minor currency units, often for cashback. In this case, $5.00 is represented as 000000000500.
	return PadNumeric(s.SecondaryAmount, length)
}

// TerminalCountryCode returns the terminal country code.
func (t *Terminal) TerminalCountryCode(session *Transaction, length int) []byte {
	/**
	The terminal country code for the USA in EMV is 0840.
	So, 0840 is the standard two-byte EMV code for U.S.-based terminals.
	**/
	// fixed length of 2 bytes
	ccode, _ := hex.DecodeString(t.Opts.CountryCode)
	return PadBinary(ccode, length)
}

// VerificationResults returns the terminal verification results of the terminals risk management checks.
func (t *Terminal) TerminalVerificationResults(session *Transaction, length int) []byte {
	// 95 (TVR): All zeroes indicate no issues detected during risk management.
	// Fixed length of 5 bytes
	vr, _ := hex.DecodeString(t.Opts.VerificationResults)
	return PadBinary(vr, length)
}

// TransactionCurrencyCode returns the transaction currency code. A two-byte code representing the currency of the transaction, in ISO numeric format.
func (t *Terminal) TransactionCurrencyCode(session *Transaction, length int) []byte {
	// 5F2A (Transaction Currency Code): A two-byte code representing the currency of the transaction, in ISO numeric format.
	return PadNumeric(t.Opts.CurrencyCode, length)
}

// TerminalTransactionDate returns the date of the transaction in YYMMDD format.
// TODO: this should get todays date
func (t *Terminal) TerminalTransactionDate(session *Transaction, length int) []byte {
	// 9A (Transaction Date): In YYMMDD format, e.g., 241104 for November 4, 2024.
	//fixed length of 3 bytes
	return PadNumeric(t.Opts.TransactionDate, length)
}

// TransactionType returns the type of transaction, e.g., purchase, cash advance, etc.
func (t *Terminal) TransactionType(s *Transaction, length int) []byte {
	// 9C (Transaction Type): 00 is the code for a purchase transaction.
	// fixed length of 1 byte
	tt, _ := hex.DecodeString(s.TransactionType)
	return tt
}

// TerminalUnpredictableNumber returns a four-byte random number generated by the terminal for transaction uniqueness.
func (t *Terminal) TerminalUnpredictableNumber(session *Transaction, length int) []byte {
	// 9F37 (Unpredictable Number): This is generated by the terminal for transaction uniqueness. Here, it's A1B2C3D4 as an example.
	// fixed length of 4 bytes
	return PadNumeric(DefaultUnpredictableNumber, length)
}

// TransactionTime returns the time of the transaction in HHMMSS format.
func (t *Terminal) TransactionTime(session *Transaction, length int) []byte {
	// 9F21 (Transaction Time): In HHMMSS format, e.g., 123456 for 12:34:56.
	return []byte("123456")
}

// TerminalType returns the type of terminal, e.g., unattended POS, ATM, etc.
func (t *Terminal) TerminalType(session *Transaction, length int) []byte {
	// 9F35 (Terminal Type): 00 is the code for an attended POS terminal.
	// Fixed length of 1 byte
	return []byte{0x00}
}

// MerchantCustomData returns additional data from the merchant, used in some specific implementations.
func (t *Terminal) MerchantCustomData(session *Transaction, length int) []byte {
	// 9F7C (Merchant Custom Data): This is additional data from the merchant, used in some specific implementations.
	return PadAlphanumeric("unknown", length)
}

// MerchantNameAndLocation returns the name and location of the merchant.
func (t *Terminal) MerchantNameAndLocation(session *Transaction, length int) []byte {
	// 9F4E (Merchant Name and Location): The name and location of the merchant.
	return PadAlphanumeric("Classbooker", length)
}

// TransactionInformation returns terminal-specific data, mainly related to EMVCo contactless payments.
func (t *Terminal) TransactionInformation(session *Transaction, length int) []byte {
	// 9F5A (Terminal Transaction Information): 123456 is a common value indicating terminal-specific data.
	return []byte("123456")
}

// FormFactorIndicator returns the form factor of the terminal device (contactless, etc.).
func (t *Terminal) FormFactorIndicator(session *Transaction, length int) []byte {
	return []byte{0x00}
}

// Capabilities returns the capabilities of the terminal, such as offline data authentication support.
func (t *Terminal) Capabilities(session *Transaction, length int) []byte {
	// 9F33 (Terminal Capabilities): 000000 is a common value indicating the terminal's capabilities.
	return []byte{0x00, 0x00, 0x00}
}

// AdditionalCapabilities returns more detailed information about the terminalâ€™s capabilities.
func (t *Terminal) AdditionalCapabilities(session *Transaction, length int) []byte {
	// 9F40 (Additional Terminal Capabilities): 123456 is a common value indicating the terminal's capabilities.
	return PadBinary([]byte("123456"), length)
}

// ApplicationPreferredName returns the terminal-preferred application name, used in some implementations.
func (t *Terminal) ApplicationPreferredName(session *Transaction, length int) []byte {
	// DF61 (Application Preferred Name): 123456 is a common value indicating the terminal-preferred application name.
	return PadBinary([]byte("123456"), length)
}

// IssuerPreferredName returns the issuer-preferred application name.
func (t *Terminal) IssuerPreferredName(session *Transaction, length int) []byte {
	// DF62 (Issuer Preferred Name): 123456 is a common value indicating the issuer-preferred application name.
	return PadBinary([]byte("12"), length)
}

// ApplicationVersionNumber returns the version of the EMV application on the card.
func (t *Terminal) ApplicationVersionNumber(session *Transaction, length int) []byte {
	// 9F09 (Application Version Number): 123456 is a common value indicating the version of the EMV application on the card.
	return PadNumeric("123456", length)
}

// ElectronicCashBalance returns the balance available for electronic cash transactions, used mainly in stored-value cards.
func (t *Terminal) ElectronicCashBalance(session *Transaction, length int) []byte {
	// 9F7B (Electronic Cash Balance): 123456 is a common value indicating the balance available for electronic cash transactions.
	// 0001 for card-present, 0002 for e-commerce, 0003 for mail order, 0004 for telephone order
	return PadNumeric("1", length)
}

// CardProgramIdentifier returns the specific program for the EMV card, relevant to specific implementations.
func (t *Terminal) CardProgramIdentifier(session *Transaction, length int) []byte {
	// 9F6D (Card Program Identifier): 123456 is a common value indicating the specific program for the EMV card.
	return PadAlphanumeric("123456", length)
}

// CardholderVerificationMethodResults returns the result of the CVM processing.
func (t *Terminal) CardholderVerificationMethodResults(session *Transaction, length int) []byte {
	// 9F34 (CVM Results): 420300 or 010000 (e.g., PIN verified).
	return PadNumeric("420300", length)
}

// TerminalFloorLimit returns the maximum amount allowed for offline transactions.
func (t *Terminal) TerminalFloorLimit(session *Transaction, length int) []byte {
	// 9F1B (Terminal Floor Limit): The maximum amount allowed for offline transactions.
	return PadNumeric("100000", length)
}

// TerminalIdentification returns a unique identifier for the terminal, typically set by the acquirer.(0) for no floor limit
func (t *Terminal) TerminalIdentification(session *Transaction, length int) []byte {
	// 9F1C (Terminal Identification): A unique identifier for the terminal, typically set by the acquirer.
	return PadAlphanumeric("0", length)
}

// MerchantCategoryCode returns the type of merchant, such as grocery, fuel, or retail.
func (t *Terminal) MerchantCategoryCode(session *Transaction, length int) []byte {
	// 9F15 (Merchant Category Code): 5411 is the code for grocery stores.
	return PadNumeric("5411", length)
}

// MerchantIdentifier returns a unique identifier for the merchant.
func (t *Terminal) MerchantIdentifier(session *Transaction, length int) []byte {
	// 9F16 (Merchant Identifier): A unique identifier for the merchant.
	return PadAlphanumeric("MERCHANT01", length)
}

// getValueforPDOL returns the value for the given tag.
func (t *Terminal) getValueforPDOL(session *Transaction, tag string, length int) []byte {
	switch tag {
	case "9F66":
		return t.TransactionQualifiers(session, length)
	case "9F02":
		return t.AuthorizedAmount(session, length)
	case "9F03":
		return t.SecondaryAmount(session, length)
	case "9F1A":
		return t.TerminalCountryCode(session, length)
	case "95":
		return t.TerminalVerificationResults(session, length)
	case "5F2A":
		return t.TransactionCurrencyCode(session, length)
	case "9A":
		return t.TerminalTransactionDate(session, length)
	case "9C":
		return t.TransactionType(session, length)
	case "9F37":
		return t.TerminalUnpredictableNumber(session, length)
	case "9F21":
		return t.TransactionTime(session, length)
	case "9F35":
		return t.TerminalType(session, length)
	case "9F7C":
		return t.MerchantCustomData(session, length)
	case "9F4E":
		return t.MerchantNameAndLocation(session, length)
	case "9F5A":
		return t.TransactionInformation(session, length)
	case "9F6E":
		return t.FormFactorIndicator(session, length)
	case "9F33":
		return t.Capabilities(session, length)
	case "9F40":
		return t.AdditionalCapabilities(session, length)
	case "DF61":
		return t.ApplicationPreferredName(session, length)
	case "DF62":
		return t.IssuerPreferredName(session, length)
	case "9F09":
		return t.ApplicationVersionNumber(session, length)
	case "9F7B":
		return t.ElectronicCashBalance(session, length)
	case "9F6D":
		return t.CardProgramIdentifier(session, length)
	case "9F34":
		return t.CardholderVerificationMethodResults(session, length)
	case "9F1B":
		return t.TerminalFloorLimit(session, length)
	case "9F1C":
		return t.TerminalIdentification(session, length)
	case "9F15":
		return t.MerchantCategoryCode(session, length)
	case "9F16":
		return t.MerchantIdentifier(session, length)

	// Discover-specific tags
	case "DF70":
		return []byte{0x01} // Mobile CVM Supported
	case "DF71":
		return []byte{0x00, 0x01} // Mobile CVM Performance
	case "DF72":
		return []byte{0x00, 0x00} // Mobile CVM Type

	default:
		// todo: If the tag of any data object identified in the DOL is unknown to the terminal or
		//represents a constructed data object, the terminal shall provide a data element
		//with the length specified and a value of all hexadecimal zeroes.
		return nil
	}
}

// BuildPDOLData builds the data for the PDOL (Processing Data Object List).
func (t *Terminal) BuildPDOLData(session *Transaction, pdol []DOL) []byte {
	pdolRequest := []byte{}

	for _, tl := range pdol {
		value := t.getValueforPDOL(session, tl.Tag, tl.Length)
		// pad the supplied value to the required length
		// figure out what I pad with 0? or 0x00?
		pdolRequest = append(pdolRequest, value...)
	}
	return pdolRequest
}

// TODO: If the length specified in the DOL entry is less than the length of the actual data
//object, the leftmost bytes of the data element shall be truncated if the data object
//has numeric (n) format,1 or the rightmost bytes of the data shall be truncated for
//any other format.

// - with leading hexadecimal zeroes if the data has numeric format
// - with trailing hexadecimal 'FF's if the data has compressed numeric (cn 1) format
// -  with trailing hexadecimal zeroes for any other format (an, ans, or b including bit combination data)

// PadNumeric pads numeric data with leading zeros
func PadNumeric(value string, length int) []byte {
	padded := fmt.Sprintf("%0*s", length*2, value) // Format to required length in hex representation
	result, _ := hex.DecodeString(padded)          // Decode hex string to byte array
	return result
}

// PadAlphanumeric pads alphanumeric data with trailing spaces (0x20)
func PadAlphanumeric(value string, length int) []byte {
	padded := fmt.Sprintf("%-*s", length, value) // Pad with spaces to required length
	return []byte(padded)
}

// PadBinary pads binary data with trailing zeros (0x00)
func PadBinary(value []byte, length int) []byte {
	if len(value) >= length {
		return value[:length] // Truncate if longer than required length
	}
	padded := make([]byte, length)
	copy(padded, value) // Copy value and leave remaining bytes as 0x00
	return padded
}
